---
layout:     post
title:      MySQL原理学习之二
subtitle:   MySQL
date:       2019-03-25
author:     WY
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - MySQL
---



###  MySQL原理学习之二

#### 事务的启动时机

- begin/start transaction 命令并不是一个事务的起点,只有执行第一个操作时,才算真正启动,
- start transaction with consistnt snapshop 立即启动一个事务

> 第一种启动方式,一致性视图在执行第一个快照读语句时创建
>
> 第二种启动方式,一致性视图在执行立即启动命令时创建的

###  视图概念

- 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
- 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，
  用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔
  离级别的实现。
- 除了自己的更新总是可见,其他三种情况
  - 版本为提交,不可见
  - 版本已提交,但是是在视图创建后提交的,不可见
  - 版本已提交,而且是在视图创建前提交的,可见

#### "快照"在MVCC里的工作机制

> 在可重复读隔离级别下,事务在启动时就拍了快照,这个快照基于整库

- InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的, transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id
- 数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id
- InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力
- 更新数据都是先读后写的,并只能读当前的值,称为当前读.

#### 事务的可重复读

> 可重复读的核心就是一致性读,而事务更新数据时,只能用当前读,如果当前的记录行锁被其他事务占用,则进入锁等待

- 读提交和可重复读的逻辑类似,它们最主要的区别是:
  - 在可重复读隔离级别下,只需要在事务开始的时候创建一致性视图,之后事务里的其他查询都共用这个一致性视图
  - 在读提交隔离级别下,每一个语句执行前都会重新算出一个新的视图

#### 索引的选择

##### 普通索引和唯一索引对更新语句性能的影响

> 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性

- 唯一索引的更新操作都要先判断这个操作是否违反唯一性约束,判断这个操作就会将数据页存入内存,存入内存后则不需要使用 change buffer

##### InnoDB处理流程

1.当更新的目标页在内存中

- 唯一索引:找到目标,判断是否冲突,插入值,执行结束
- 普通索引:找到目标,插入值,执行结束

2.当更新目标不在内存中

- 唯一索引: 将数据页读入内存.判断冲突,插入值,执行结束
- 普通索引: 将更新记录在change buffer里,执行结束

> 将数据从磁盘读入内存涉及随机IO的访问,是数据库里成本最高的操作,而change buffer减少了随机磁盘的访问

##### change buffer 使用场景

- 记录的变更越多,收益越大
- 记录之后,做查询操作,反而加大了change buffer维护代价

### 索引选择异常和处理

- **force index** 强行选择一个索引
- 修改语句,引导MySQL使用我们期望的索引
- 新建一个更合适的索引,来提供给优化器做选择,或删掉误用的索引

### 前缀索引

> 定义好长度,就可以做到既节省空间,又不用额外增加太多的查询成本

- 使用倒序存储,以加强足够的区分度
- 使用hash字段

当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页

InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：

- 还没有使用的
- 使用了并且是干净页
- 使用了并且是脏页

### InnoDB刷脏页的控制策略

- `innodb_io_capacity`参数会告诉InnoDB你的磁盘能力