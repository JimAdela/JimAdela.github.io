---
layout:     post
title:      PHP与MySQL
subtitle:   基础复习
date:       2019-03-03
author:     WY
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - PHP
---

## PHP引用变量的概念和定义方式

> 概念

- 在PHP中引用意味着用不同的名字访问同一个变量内容.

> 定义方式

- 使用   &  符号

> 工作原理

- COW copy on write
- 赋值并不会新开辟一块新的内存空间,只有当写操作发生时,才会新开一块内存.
- 查看内存使用情况函数: memory_get_usage()
- 使用引用的话,两个变量永远指向一个内存空间,写操作不会新开辟内存.
- 查看zval结构体函数: xdebug_debug_zval() 
  - 需要安装扩展
  - 结构体: refcount 指向内存空间的个数 is_ref 是否是引用
- unset只会取消引用,不会销毁空间



## MySQL数据类型

> varchar 

- 用于存储可变长度的字符串,它比定长类型更节省空间
- 使用1或2个额外字节记录字符串的长度,列长度小于255字节,使用1个字节表示,否则用2个
- 如果存储空间超过指定长度,会被截断

> char

- char 是定长的,根据定义的字符串长度分配足够的空间
- char会根据需要采用空格进行填充以方便比较
- 适合存储很短的字符串,或者 所有值都接近同一个长度
- 超出设定的长度,会被截断
- 对于经常变更的数据,char比varchar更好,char不容易产生碎片
- 对于非常短的列,char 比varchar在存储空间上更有效率

> 枚举

- 可以代替常用的字符串类型
- 把不重复的集合存储成一个预定义的集合
- 把列表值压缩成一个或两个字节
- 内部存储的是整数
- 尽量避免使用数字作为enum枚举的常量,易混乱
- 排序是按照内部存储的整数进行排序



> 日期和时间类型

- 尽量使用timestamp 比datetime空间效率高

- 用整数保存时间戳的格式通常不方便处理

- 如果需要存储微秒, 可以使用bigint存储

  ​

> MySQL锁机制

- 读索: 共享的,不堵塞,多个用户可以同时读一个资源,互不干扰
- 共享锁和排他锁,其实就是读锁和写锁
- 写锁: 排他的,一个写锁会阻塞其他的写锁和读锁.,只允许一个人写入,防止其他用户读取正在写入的资源

> 锁粒度

- 表锁,系统 性能开销最小,会锁定整张表,MyISAM使用表锁
- 行锁,最大程度地支持并发处理,但也带来最大的锁开销.InnoDB实现行级索

> 事务处理

- MySQL提供事务处理的 表引擎,InnoDB
- 服务器层不管理事务,由下层的引擎实现,所以同一个事务中,使用多种存储引擎不靠谱  
- 在非事务的表上执行事务操作MySQL不会发出提醒,也不会报错

>  存储过程

- 为以后的使用而保存的一条或多条MySQL语句的集合
- 存储过程就是有业务逻辑和流程的集合
- 可以在存储过程中创建表,更新数据, 删除等
- 使用场景
  - 通过把处理封装在容易使用的单元中,简化复杂的操作
  - 保证数据的一致性
  - 简化对变动的管理

> 触发器

- 提供给程序员和数据分析员来保证数据完整性的一种方法.它是与表事件相关的特殊的存储过程
- 使用场景
  - 可通过数据库中的相关表实现级联更改
  - 实时监控某张表中的某个字段的更改而需要做出相应的处理
  - 某些业务编号的生成
  - 滥用会造成数据库及应用程序的维护困难



### MySQL索引

> 索引的基础

- 索引类似书籍的目录,要想找到一本书的某个特定主题,需要先查找书的目录,定位对应的页码
- 存数引擎使用类似的方式进行数据查询.先去索引中找到对应的值,然后根据匹配的索引找到对应的数据行

> 索引对性能的影响

- 大大减少服务器需要扫描的数据量
- 帮助服务器避免排序和临时表
- 将随机IO变成顺序IO
- 大大 提供查询速度.降低写的速度,占用磁盘
- 使用场景
  - 小表,大部分全表扫描效率更高
  - 特大表,建立和使用索引的代价将随之增长,可以使用分区表技术解决

> 索引的类型

- 索引有很多种类型,都是实现在存储引擎层的
- 普通索引:最基本的索引,没有任何约束限制
- 唯一索引:与普通索引类似,但是具有唯一性约束
- 主键索引:特殊的唯一索引.不许有空值
- 一个表只能有一个主键索引,可以有多个唯一索引
- 主键索引一定是唯一索引,唯一索引不是主键索引\
- 主键可以与外键构成参照完整性约束,防止数据不一致
- 组合索引:将多个列组合在一起创建索引,可以覆盖多个列
- 外键索引: 只有InnoDB类型的表才可以使用.保证数据的一致性,完整性和实现联机操作
- 全文索引: MySQL自带的全文索引只能用于MyISAM,并且只能对英文进行全文检索
- 原则
  - 最适合索引的列是在where字句中的列,或连接字句中的列
  - 索引列基数越大, 效果越好
  - 对字符串进行索引,应该指定一个前缀长度,可以节省大量的 索引空间
  - 根据情况创建复合索引,可以提供查询效率
  - 避免创建过多索引,会额外占用磁盘空间,降低写操作效率
  - 主键尽量选择较短的数据类型,可以有效减少索引的磁盘占用提高查询效率
  - 复合索引遵循前缀原则
  - like查询, %不能在前,可以使用全文索引
  - column is null 可以使用索引
  - 如果mysql估计使用索引会比全表扫码更慢,会放弃使用索引
  - 如果or前的条件中的 列有索引,后面的没.索引不会被用到
  - 列类型是字符串,查询时一定要给值加引号,否则索引失效

### 查找分析查询速度慢的原因

- 使用show profile
- set profiling = 1; 开启,服务器上执行的所有语句会检测消耗的时间,存到临时表中
- show profiles
- show profile for query 临时表iD

> 使用show status

- show status 会返回一些计数器, show global status 查看服务器级别的所有计数
- 跟进计数,可以猜测哪些操作代价较高或者消耗时间多

> 使用show processlist

- 观察是否有大量线程处于不正常的状态或者特征

> 使用explain

- 分析单条sql语句

> 慢查询日志

###优化查询过程中的数据访问

- 访问数据太多导致查询性能下降
- 确定应用程序是否在检索大量超过需要的数据,可能是太多行或列
- 确认mysql服务器是否在分析大量不必要的数据行

> 避免使用如下sql 语句

- 查询不需要的记录,使用limit解决
- 多表关联返回全部列,指定返回字段值
- 总是取出全部列,select* 会让优化器无法完成索引覆盖扫描的优化
- 重复查询相同的数据,可以缓存数据,下次直接读取缓存

> 是否在扫描额外的记录

- 使用explain来进行分析,如果发现查询需要扫描大量的数据但只返回少数的行,可以通过如下技巧去优化
- 使用索引覆盖扫描,把所有用的列都放到索引中,这样存储引擎不需要回表获取对应行就可以返回结果

> 改变数据库和表的结构,修改数据表的范式

- 重写sql语句, 让优化器可以以更优的方式执行查询

> 切分查询

- 将一个大的查询分为多个小的相同的查询
- 一次性删除1000万的数据要比一次删除1万, 暂停一会的方案更加损耗服务器开销

> 分解关联查询

- 可以将一条关联语句分解成多条sql来执行
- 让缓存的效率更高
- 执行单个查询可以减少锁的竞争
- 在应用层做关联可以更容易对数据库进行拆分



> 优化count() 查询

- count(*)中的 * 会忽略所有的列,直接统计所有的列数, 因此不要使用count( 列名)
- MyISAM中,没有where条件的count(*)非常快
- 当有where条件,MyISAM的count统计不一定比其他表引擎快
- 可以使用explain查询近似值,用近似值替代count(*)
- 增加汇总表,使用缓存 

> 优化关联查询

- 确定on 或者 using 字句的列上有索引
- 确保group by 和 order by 中只有一个表的列,这样MySQL才有可能使用索引

> 优化group by 和 distinct

- 使用索引优化
- 关联查询中,使用标识列进行分组的效率会更高
- 如果不需要order by , 进行group by 时使用order by null , MySQL不会在对文件排序
- with rollup 超级聚合, 可以挪到应用程序处理

> 优化limit分页

- limit偏移量大的时候,查询效率低
- 可以记录上次查询的最大id, 下次查询时直接跟进该id来查询

> 优化union查询

- union all 的效率高于union